package command

import (
	"time"
	"os"
	"github.com/fsnotify/fsnotify"
	"io/ioutil"
	"path/filepath"
	"strings"
	"regexp"
	"os/exec"
	"bytes"
	"runtime"
)

var (
	cmd                 *exec.Cmd
	eventTime           = make(map[string]int64)
	watchExts           = []string{".go"}
	ignoredFilesRegExps = []string{
		`.#(\w+).go`,
		`.(\w+).go.swp`,
		`(\w+).go~`,
		`(\w+).tmp`,
		`(\w+).exe`,
	}
)

func start(appPackage, appName, env string) {
	printInfo("Restarting '%s'...", appName)
	app := appName
	if !strings.Contains(appName, "./") {
		appName = "./" + appName
	}
	var args []string
	if env == "" {
		args = []string{"-n", app}
	} else {
		args = []string{"-e", env, "-n", app}
	}
	cmd = exec.Command(appName, args...)
	cmd.Dir = appPackage
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	go cmd.Run()
	printSuccess("'%s' is running...", appName)
}

func kill() {
	defer func() {
		if e := recover(); e != nil {
			printInfo("Kill recover: %s", e)
		}
	}()
	if cmd != nil && cmd.Process != nil {
		err := cmd.Process.Kill()
		if err != nil {
			printError("Error while killing cmd process: %s", err)
		}
	}
}

func build(appPackage, appName string) {
	printInfo("Start building ...")
	cmdName := "go"
	var (
		err    error
		stderr bytes.Buffer
	)
	if runtime.GOOS == "windows" {
		appName += ".exe"
	}
	args := []string{"build"}
	args = append(args, "-o", appName)
	cmd := exec.Command(cmdName, args...)
	cmd.Dir = appPackage
	cmd.Env = append(os.Environ(), "GOGC=off")
	cmd.Stderr = &stderr
	err = cmd.Run()
	if err != nil {
		printError("Failed to build the application: %s", stderr.String())
		return
	}
	printInfo("Built Successfully.")
}

func Watch(appPackage, appName, env string) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		printError(err.Error())
	}
	defer watcher.Close()

	go func() {
		for {
			select {
			case e := <-watcher.Events:
				isBuild := true
				if shouldIgnoreFile(e.Name) {
					continue
				}
				if !shouldWatchFileWithExtension(e.Name) {
					continue
				}
				mt := getFileModTime(e.Name)
				if t := eventTime[e.Name]; mt == t {
					isBuild = false
				}
				eventTime[e.Name] = mt
				if isBuild {
					print("File changed: %s", e.Name)
					go func() {
						// Wait 1s before autobuild until there is no file change.
						time.Sleep(1 * time.Second)
						build(appPackage, appName)
						kill()
						start(appPackage, appName, env)
					}()
				}
			case err := <-watcher.Errors:
				printError("goo error: %s", err.Error())
			}
		}
	}()
	var paths []string
	currPath, _ := os.Getwd()
	getAllPath(filepath.Join(currPath, appPackage), &paths)
	for _, path := range paths {
		err = watcher.Add(path)
		if err != nil {
			printError(err.Error())
		}
	}
	build(appPackage, appName)
	kill()
	start(appPackage, appName, env)
	var done chan bool
	<-done
}

func getAllPath(currPath string, paths *[]string) {
	*paths = append(*paths, currPath)
	dirs, err := ioutil.ReadDir(currPath)
	if err != nil {
		return
	}
	for _, dir := range dirs {
		if dir.IsDir() {
			getAllPath(filepath.Join(currPath, dir.Name()), paths)
		}
	}
}

// GetFileModTime returns unix timestamp of `os.File.ModTime` for the given path.
func getFileModTime(path string) int64 {
	path = strings.Replace(path, "\\", "/", -1)
	f, err := os.Open(path)
	if err != nil {
		return time.Now().Unix()
	}
	defer f.Close()
	fi, err := f.Stat()
	if err != nil {
		return time.Now().Unix()
	}
	return fi.ModTime().Unix()
}

// shouldIgnoreFile ignores filenames generated by Emacs, Vim or SublimeText.
// It returns true if the file should be ignored, false otherwise.
func shouldIgnoreFile(filename string) bool {
	for _, regex := range ignoredFilesRegExps {
		r, err := regexp.Compile(regex)
		if err != nil {
			printError("Could not compile regular expression: %s", err)
		}
		if r.MatchString(filename) {
			return true
		}
		continue
	}
	return false
}

// shouldWatchFileWithExtension returns true if the name of the file
// hash a suffix that should be watched.
func shouldWatchFileWithExtension(name string) bool {
	for _, s := range watchExts {
		if strings.HasSuffix(name, s) {
			return true
		}
	}
	return false
}
